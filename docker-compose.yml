# docker-compose.yml

version: '3.8' # Specifies the Docker Compose file format version

services:
  # MySQL Database Service
  db:
    image: mysql:8.0 # Use a specific version of MySQL, e.g., 8.0 or 5.7 for stability
    container_name: ${PROJECT_NAME}_db # Dynamic container name using .env variable
    command: '--default-authentication-plugin=mysql_native_password' # Ensures compatibility with older clients/WordPress
    volumes:
      - db_data:/var/lib/mysql # Named volume for persistent database storage
    ports:
      - "${MYSQL_HOST_PORT:-3306}:3306" # Expose MySQL port to host (optional, for external DB tools)
    restart: always # Restart policy
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD} # Root password for MySQL
      MYSQL_DATABASE: ${MYSQL_DATABASE}           # Database name for WordPress
      MYSQL_USER: ${MYSQL_USER}                   # Username for WordPress database access
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}           # Password for WordPress database user
    networks:
      - wordpress_network # Connect to the custom network

  # WordPress Service - Modified to use a Dockerfile
  wordpress:
    build:
      context: . # Specifies that Docker should look for the Dockerfile in the current directory (project root)
      args:
        WORDPRESS_IMAGE_TAG: latest # Argument passed to Dockerfile, can be e.g., php8.1-apache, php8.2-apache
    container_name: ${PROJECT_NAME}_wordpress # Dynamic container name
    depends_on:
      - db # Ensures 'db' service starts before 'wordpress'
    ports:
      - "${WORDPRESS_HOST_PORT:-8000}:80" # Map host port (default 8000) to container port 80
    restart: always
    volumes:
      - ./wp-content:/var/www/html/wp-content # Mount local wp-content directory into the container
      # - ./config/php/php.ini:/usr/local/etc/php/conf.d/custom.ini # Optional: Mount custom php.ini for PHP settings
    environment:
      WORDPRESS_DB_HOST: db:3306             # WordPress database host (service name 'db' and port)
      WORDPRESS_DB_USER: ${MYSQL_USER}       # WordPress database username (from .env)
      WORDPRESS_DB_PASSWORD: ${MYSQL_PASSWORD} # WordPress database password (from .env)
      WORDPRESS_DB_NAME: ${MYSQL_DATABASE}   # WordPress database name (from .env)
      WORDPRESS_TABLE_PREFIX: ${WORDPRESS_TABLE_PREFIX:-wp_} # Table prefix (from .env, default 'wp_')
      # WP_HOME & WP_SITEURL are useful for local development to ensure correct URL generation
      WP_HOME: http://localhost:${WORDPRESS_HOST_PORT:-8000}
      WP_SITEURL: http://localhost:${WORDPRESS_HOST_PORT:-8000}
      WORDPRESS_DEBUG: ${WORDPRESS_DEBUG:-1} # Enable WordPress debug mode (from .env, default 1/true)
    networks:
      - wordpress_network # Connect to the custom network

  # phpMyAdmin Service
  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest # Use the latest official phpMyAdmin image
    container_name: ${PROJECT_NAME}_phpmyadmin # Dynamic container name
    depends_on:
      - db # Ensures 'db' service is available
    ports:
      - "${PHPMYADMIN_HOST_PORT:-8081}:80" # Map host port (default 8081) to container port 80
    restart: always
    environment:
      PMA_HOST: db # MySQL host (service name 'db')
      PMA_PORT: 3306 # MySQL port
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD} # Allows login to phpMyAdmin with MySQL root user (from .env)
      UPLOAD_LIMIT: 1G # Optional: Increase file upload limit for database dumps, etc.
    networks:
      - wordpress_network # Connect to the custom network

# Named volumes for data persistence
volumes:
  db_data: {} # Defines the 'db_data' volume for MySQL

# Custom network for inter-service communication
networks:
  wordpress_network:
    driver: bridge # Use the bridge driver for the network