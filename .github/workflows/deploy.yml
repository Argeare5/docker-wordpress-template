name: Deploy to Server

# Controls when the action will run.
# Triggers the workflow on push events to the 'main' branch.
on:
  push:
    branches:
      - main # Adjust this to your production/deployment branch if different (e.g., master, production)

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest # Specifies the runner environment

    steps:
      # Step 1: Checkout the repository code
      # This action checks-out your repository under $GITHUB_WORKSPACE, so your workflow can access it.
      - name: Checkout code
        uses: actions/checkout@v4 # Using version 4, check for latest stable version

      # Step 2: Create .env file for server from GitHub Secrets
      - name: Create server .env file
        # Pass all secrets as environment variables to this step for safer handling
        env:
          VAR_PROD_PROJECT_NAME: ${{ secrets.PROD_PROJECT_NAME }}
          VAR_PROD_MYSQL_ROOT_PASSWORD: ${{ secrets.PROD_MYSQL_ROOT_PASSWORD }}
          VAR_PROD_MYSQL_DATABASE: ${{ secrets.PROD_MYSQL_DATABASE }}
          VAR_PROD_MYSQL_USER: ${{ secrets.PROD_MYSQL_USER }}
          VAR_PROD_MYSQL_PASSWORD: ${{ secrets.PROD_MYSQL_PASSWORD }}
          VAR_PROD_WORDPRESS_HOST_PORT: ${{ secrets.PROD_WORDPRESS_HOST_PORT }}
          VAR_PROD_WORDPRESS_TABLE_PREFIX: ${{ secrets.PROD_WORDPRESS_TABLE_PREFIX }}
          VAR_PROD_WORDPRESS_DEBUG: ${{ secrets.PROD_WORDPRESS_DEBUG }}
          VAR_PROD_WP_ENV: ${{ secrets.PROD_WP_ENV }}
          VAR_PROD_AUTH_KEY: ${{ secrets.AUTH_KEY }}
          VAR_PROD_SECURE_AUTH_KEY: ${{ secrets.SECURE_AUTH_KEY }}
          VAR_PROD_LOGGED_IN_KEY: ${{ secrets.LOGGED_IN_KEY }}
          VAR_PROD_NONCE_KEY: ${{ secrets.NONCE_KEY }}
          VAR_PROD_AUTH_SALT: ${{ secrets.AUTH_SALT }}
          VAR_PROD_SECURE_AUTH_SALT: ${{ secrets.SECURE_AUTH_SALT }}
          VAR_PROD_LOGGED_IN_SALT: ${{ secrets.LOGGED_IN_SALT }}
          VAR_PROD_NONCE_SALT: ${{ secrets.NONCE_SALT }}
          VAR_PROD_PHPMYADMIN_PORT: ${{ secrets.PROD_PHPMYADMIN_PORT }}
          VAR_PROD_PHPMYADMIN_UPLOAD_LIMIT: ${{ secrets.PROD_PHPMYADMIN_UPLOAD_LIMIT }}
        run: |
          echo "Creating .env file for server..."
          # Using a block to redirect all printf output to .env file
          {
            printf "PROD_PROJECT_NAME='%s'\n" "$VAR_PROD_PROJECT_NAME"
            printf "PROD_MYSQL_ROOT_PASSWORD='%s'\n" "$VAR_PROD_MYSQL_ROOT_PASSWORD"
            printf "PROD_MYSQL_DATABASE='%s'\n" "$VAR_PROD_MYSQL_DATABASE"
            printf "PROD_MYSQL_USER='%s'\n" "$VAR_PROD_MYSQL_USER"
            printf "PROD_MYSQL_PASSWORD='%s'\n" "$VAR_PROD_MYSQL_PASSWORD"
            printf "PROD_WORDPRESS_HOST_PORT='%s'\n" "$VAR_PROD_WORDPRESS_HOST_PORT"
            printf "PROD_WORDPRESS_TABLE_PREFIX='%s'\n" "$VAR_PROD_WORDPRESS_TABLE_PREFIX"
            printf "PROD_WORDPRESS_DEBUG='%s'\n" "$VAR_PROD_WORDPRESS_DEBUG"
            printf "PROD_WP_ENV='%s'\n" "$VAR_PROD_WP_ENV"
            printf "PROD_AUTH_KEY='%s'\n" "$VAR_PROD_AUTH_KEY"
            printf "PROD_SECURE_AUTH_KEY='%s'\n" "$VAR_PROD_SECURE_AUTH_KEY"
            printf "PROD_LOGGED_IN_KEY='%s'\n" "$VAR_PROD_LOGGED_IN_KEY"
            printf "PROD_NONCE_KEY='%s'\n" "$VAR_PROD_NONCE_KEY"
            printf "PROD_AUTH_SALT='%s'\n" "$VAR_PROD_AUTH_SALT"
            printf "PROD_SECURE_AUTH_SALT='%s'\n" "$VAR_PROD_SECURE_AUTH_SALT"
            printf "PROD_LOGGED_IN_SALT='%s'\n" "$VAR_PROD_LOGGED_IN_SALT"
            printf "PROD_NONCE_SALT='%s'\n" "$VAR_PROD_NONCE_SALT"
            printf "PROD_PHPMYADMIN_PORT='%s'\n" "$VAR_PROD_PHPMYADMIN_PORT"
            printf "PROD_PHPMYADMIN_UPLOAD_LIMIT='%s'\n" "$VAR_PROD_PHPMYADMIN_UPLOAD_LIMIT"
          } > .env
          echo "Finished creating .env file. Content:"
          cat .env
        # This .env file is created in the root of the checkout in the Actions runner

      # Step 3: Deploy files to DigitalOcean Droplet using rsync over SSH
      # This action securely copies files from the runner to your server.
      - name: Deploy files using rsync
        uses: easingthemes/ssh-deploy@v5.0.0 # Check for the latest version of this action
        with:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          ARGS: "-rlgoDzvc -i --delete --exclude='.git*'" # rsync arguments
            # -r: recursive
            # -l: copy symlinks as symlinks
            # -g: preserve group
            # -o: preserve owner (useful if deploying as root)
            # -D: preserve devices and special files
            # -z: compress file data during the transfer
            # -v: verbose
            # -c: skip based on checksum, not mod-time & size
            # -i: output a change-summary for all updates
            # --delete: delete extraneous files from dest dirs
          # --exclude='.git*': exclude .git directory and related files
          SOURCE: "./"  # Source directory (root of your repository checkout)
            # This will copy all files including the generated .env, wp-content,
          # docker-compose.prod.yml, and config/ directory.
          REMOTE_HOST: ${{ secrets.SSH_HOST }}
          REMOTE_USER: ${{ secrets.SSH_USER }} # Should be 'root' in your case
          TARGET: ${{ secrets.SERVER_PROJECT_PATH }} # Your server path: /home/wordpress-template/

      # Step 4: Execute deployment commands on the server via SSH
      - name: Execute remote commands
        uses: appleboy/ssh-action@v1.0.3 # Or latest stable version
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }} # 'root'
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "Navigating to project directory on server: ${{ secrets.SERVER_PROJECT_PATH }}"
            cd ${{ secrets.SERVER_PROJECT_PATH }}

            echo "Ensuring .env file is in place..."
            if [ ! -f .env ]; then
              echo "ERROR: Server .env file not found at ${{ secrets.SERVER_PROJECT_PATH }}/.env !"
              # Attempt to use .env_server if it exists from a previous rsync version
              if [ -f .env_server ]; then
                echo "Found .env_server, renaming to .env"
                mv -f .env_server .env
              else
                exit 1 # Exit if no .env file can be established
              fi
            fi
            echo "Server .env file content:"
            cat .env # For debugging, consider removing this in true production for security

            echo "Pulling latest versions of base images specified in docker-compose.prod.yml..."
            docker compose -f docker-compose.prod.yml pull

            echo "Bringing up Docker containers using docker-compose.prod.yml..."
            docker compose -f docker-compose.prod.yml up -d --force-recreate --remove-orphans

            echo "Waiting for WordPress container to be up..."
            sleep 15

            WORDPRESS_CONTAINER_ID=$(docker compose -f docker-compose.prod.yml ps -q wordpress_prod)
            if [ -z "$WORDPRESS_CONTAINER_ID" ]; then
              echo "ERROR: WordPress container (wordpress_prod) not found or not running!"
              # Attempt to get logs if container exists but is not running
              docker compose -f docker-compose.prod.yml logs wordpress_prod
              exit 1
            fi
            echo "WordPress container ID: $WORDPRESS_CONTAINER_ID"

            echo "Running composer install for main wp-content..."
            docker exec -T "$WORDPRESS_CONTAINER_ID" composer install --no-interaction --no-progress --no-dev --optimize-autoloader --working-dir=/var/www/html/wp-content

            # --- Universal Composer Install for Plugins ---
            echo "Searching for composer.json in plugins and running install..."
            PLUGINS_BASE_DIR="/var/www/html/wp-content/plugins"
            # Using docker exec to run find and the loop *inside* the container
            # This ensures paths are correct from container's perspective and Composer runs in its environment
            docker exec -T "$WORDPRESS_CONTAINER_ID" bash -c \
            'find '"$PLUGINS_BASE_DIR"' -maxdepth 2 -name composer.json -print0 | while IFS= read -r -d "" composer_file; do \
                plugin_dir=$(dirname "$composer_file"); \
                echo "Found composer.json in $plugin_dir. Running composer install..."; \
                composer install --no-interaction --no-progress --no-dev --optimize-autoloader --working-dir="$plugin_dir"; \
            done'
            
            # --- Universal Composer Install for Themes ---
            echo "Searching for composer.json in themes and running install..."
            THEMES_BASE_DIR="/var/www/html/wp-content/themes"
            docker exec -T "$WORDPRESS_CONTAINER_ID" bash -c \
            'find '"$THEMES_BASE_DIR"' -maxdepth 2 -name composer.json -print0 | while IFS= read -r -d "" composer_file; do \
                theme_dir=$(dirname "$composer_file"); \
                echo "Found composer.json in $theme_dir. Running composer install..."; \
                composer install --no-interaction --no-progress --no-dev --optimize-autoloader --working-dir="$theme_dir"; \
            done'

            echo "Optional: Running WordPress specific commands (e.g., clear cache, DB updates if needed via wp-cli)"
            # docker exec -T "$WORDPRESS_CONTAINER_ID" wp theme activate your_theme_slug --allow-root
            # docker exec -T "$WORDPRESS_CONTAINER_ID" wp cache flush --allow-root
            # docker exec -T "$WORDPRESS_CONTAINER_ID" wp core update-db --allow-root

            echo "Deployment finished successfully!"