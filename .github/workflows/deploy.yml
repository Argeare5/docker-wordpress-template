# .github/workflows/deploy.yml

name: Deploy WordPress to DigitalOcean Droplet

# Controls when the action will run.
# Triggers the workflow on push events to the 'main' branch.
on:
  push:
    branches:
      - main # Adjust this to your production/deployment branch if different (e.g., master, production)

jobs:
  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest # Specifies the runner environment

    steps:
      # Step 1: Checkout the repository code
      # This action checks-out your repository under $GITHUB_WORKSPACE, so your workflow can access it.
      - name: Checkout code
        uses: actions/checkout@v4 # Using version 4, check for latest stable version

      # Step 2: Create .env file for server from GitHub Secrets
      - name: Create server .env file
        # Pass all secrets as environment variables to this step for safer handling
        env:
          VAR_PROD_PROJECT_NAME: ${{ secrets.PROD_PROJECT_NAME }}
          VAR_PROD_MYSQL_ROOT_PASSWORD: ${{ secrets.PROD_MYSQL_ROOT_PASSWORD }}
          VAR_PROD_MYSQL_DATABASE: ${{ secrets.PROD_MYSQL_DATABASE }}
          VAR_PROD_MYSQL_USER: ${{ secrets.PROD_MYSQL_USER }}
          VAR_PROD_MYSQL_PASSWORD: ${{ secrets.PROD_MYSQL_PASSWORD }}
          VAR_PROD_WORDPRESS_HOST_PORT: ${{ secrets.PROD_WORDPRESS_HOST_PORT }}
          VAR_PROD_WORDPRESS_TABLE_PREFIX: ${{ secrets.PROD_WORDPRESS_TABLE_PREFIX }}
          VAR_PROD_WORDPRESS_DEBUG: ${{ secrets.PROD_WORDPRESS_DEBUG }}
          VAR_PROD_WP_ENV: ${{ secrets.PROD_WP_ENV }}
          VAR_PROD_AUTH_KEY: ${{ secrets.AUTH_KEY }}
          VAR_PROD_SECURE_AUTH_KEY: ${{ secrets.SECURE_AUTH_KEY }}
          VAR_PROD_LOGGED_IN_KEY: ${{ secrets.LOGGED_IN_KEY }}
          VAR_PROD_NONCE_KEY: ${{ secrets.NONCE_KEY }}
          VAR_PROD_AUTH_SALT: ${{ secrets.AUTH_SALT }}
          VAR_PROD_SECURE_AUTH_SALT: ${{ secrets.SECURE_AUTH_SALT }}
          VAR_PROD_LOGGED_IN_SALT: ${{ secrets.LOGGED_IN_SALT }}
          VAR_PROD_NONCE_SALT: ${{ secrets.NONCE_SALT }}
          VAR_PROD_PHPMYADMIN_PORT: ${{ secrets.PROD_PHPMYADMIN_PORT }}
          VAR_PROD_PHPMYADMIN_UPLOAD_LIMIT: ${{ secrets.PROD_PHPMYADMIN_UPLOAD_LIMIT }}
        run: |
          echo "Creating .env file for server..."
          # Using a block to redirect all printf output to .env file
          {
            printf "PROD_PROJECT_NAME='%s'\n" "$VAR_PROD_PROJECT_NAME"
            printf "PROD_MYSQL_ROOT_PASSWORD='%s'\n" "$VAR_PROD_MYSQL_ROOT_PASSWORD"
            printf "PROD_MYSQL_DATABASE='%s'\n" "$VAR_PROD_MYSQL_DATABASE"
            printf "PROD_MYSQL_USER='%s'\n" "$VAR_PROD_MYSQL_USER"
            printf "PROD_MYSQL_PASSWORD='%s'\n" "$VAR_PROD_MYSQL_PASSWORD"
            printf "PROD_WORDPRESS_HOST_PORT='%s'\n" "$VAR_PROD_WORDPRESS_HOST_PORT"
            printf "PROD_WORDPRESS_TABLE_PREFIX='%s'\n" "$VAR_PROD_WORDPRESS_TABLE_PREFIX"
            printf "PROD_WORDPRESS_DEBUG='%s'\n" "$VAR_PROD_WORDPRESS_DEBUG"
            printf "PROD_WP_ENV='%s'\n" "$VAR_PROD_WP_ENV"
            printf "PROD_AUTH_KEY='%s'\n" "$VAR_PROD_AUTH_KEY"
            printf "PROD_SECURE_AUTH_KEY='%s'\n" "$VAR_PROD_SECURE_AUTH_KEY"
            printf "PROD_LOGGED_IN_KEY='%s'\n" "$VAR_PROD_LOGGED_IN_KEY"
            printf "PROD_NONCE_KEY='%s'\n" "$VAR_PROD_NONCE_KEY"
            printf "PROD_AUTH_SALT='%s'\n" "$VAR_PROD_AUTH_SALT"
            printf "PROD_SECURE_AUTH_SALT='%s'\n" "$VAR_PROD_SECURE_AUTH_SALT"
            printf "PROD_LOGGED_IN_SALT='%s'\n" "$VAR_PROD_LOGGED_IN_SALT"
            printf "PROD_NONCE_SALT='%s'\n" "$VAR_PROD_NONCE_SALT"
            printf "PROD_PHPMYADMIN_PORT='%s'\n" "$VAR_PROD_PHPMYADMIN_PORT"
            printf "PROD_PHPMYADMIN_UPLOAD_LIMIT='%s'\n" "$VAR_PROD_PHPMYADMIN_UPLOAD_LIMIT"
          } > .env
          echo "Finished creating .env file. Content:"
          cat .env
        # This .env file is created in the root of the checkout in the Actions runner

      # Step 3: Deploy files to DigitalOcean Droplet using rsync over SSH
      # This action securely copies files from the runner to your server.
      - name: Deploy files using rsync
        uses: easingthemes/ssh-deploy@v5.0.0 # Check for the latest version of this action
        with:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          ARGS: "-rlgoDzvc -i --delete --exclude='.git*'" # rsync arguments
            # -r: recursive
            # -l: copy symlinks as symlinks
            # -g: preserve group
            # -o: preserve owner (useful if deploying as root)
            # -D: preserve devices and special files
            # -z: compress file data during the transfer
            # -v: verbose
            # -c: skip based on checksum, not mod-time & size
            # -i: output a change-summary for all updates
            # --delete: delete extraneous files from dest dirs
          # --exclude='.git*': exclude .git directory and related files
          SOURCE: "./"  # Source directory (root of your repository checkout)
            # This will copy all files including the generated .env, wp-content,
          # docker-compose.prod.yml, and config/ directory.
          REMOTE_HOST: ${{ secrets.SSH_HOST }}
          REMOTE_USER: ${{ secrets.SSH_USER }} # Should be 'root' in your case
          TARGET: ${{ secrets.SERVER_PROJECT_PATH }} # Your server path: /home/wordpress-template/

      # Step 4: Execute deployment commands on the server via SSH
      - name: Execute remote commands
        uses: appleboy/ssh-action@v1.0.3 # Check for the latest version of this action
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }} # 'root'
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "Navigating to project directory on server: ${{ secrets.SERVER_PROJECT_PATH }}"
            cd ${{ secrets.SERVER_PROJECT_PATH }}

            echo "Current directory content (before .env move):"
            ls -la

            echo "Moving .env file to correct location if it was created by a previous step in root of checkout..."
            # Assuming .env was created in the root of the checkout ($GITHUB_WORKSPACE) by the 'Create server .env file' step
            # and rsync copied it to ${{ secrets.SERVER_PROJECT_PATH }}/.env
            # If it was named .env_server and needs renaming:
            # if [ -f .env_server ]; then
            #   echo "Renaming .env_server to .env..."
            #   mv -f .env_server .env
            # fi
            # Ensure .env exists now:
            if [ ! -f .env ]; then
              echo "ERROR: Server .env file not found at ${{ secrets.SERVER_PROJECT_PATH }}/.env !"
              exit 1
            fi
            echo "Server .env file content:"
            cat .env

            echo "Pulling latest versions of base images specified in docker-compose.prod.yml..."
            docker compose -f docker-compose.prod.yml pull

            echo "Bringing up Docker containers using docker-compose.prod.yml..."
            docker compose -f docker-compose.prod.yml up -d --force-recreate --remove-orphans

            echo "Waiting for WordPress container to be up..."
            # You might need a short sleep or a more robust check if composer install fails immediately
            sleep 10 

            echo "Running composer install inside the WordPress container..."
            # Ensure your wordpress_prod service has Composer installed (e.g., via your custom Dockerfile)
            # The -T flag disables pseudo-tty allocation, which is good for non-interactive scripts.
            docker compose -f docker-compose.prod.yml exec -T wordpress_prod composer install --no-interaction --no-progress --no-dev --optimize-autoloader --working-dir=/var/www/html/wp-content

            echo "Optional: Running WordPress specific commands (e.g., clear cache, DB updates if needed via wp-cli)"
            # docker compose -f docker-compose.prod.yml exec -T wordpress_prod wp theme activate your_theme_slug --allow-root
            # docker compose -f docker-compose.prod.yml exec -T wordpress_prod wp cache flush --allow-root
            # docker compose -f docker-compose.prod.yml exec -T wordpress_prod wp core update-db --allow-root

            echo "Deployment finished successfully!"